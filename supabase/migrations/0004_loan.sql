-- ====================================================================
-- Loans schema migration (PostgreSQL)
-- - Normalized contacts
-- - Role-based loan_parties (buyer/seller/etc)
-- - Payment schedule with check-off capability
-- - Aggregates and next due date auto-maintained
-- - Verbose comments explaining payment_amount vs expected/paid/is_paid
-- ====================================================================

BEGIN;

-- ------------------------------------------------
-- Types
-- ------------------------------------------------
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'loan_party_role') THEN
    CREATE TYPE loan_party_role AS ENUM ('buyer','seller','cosigner','guarantor','servicer');
  END IF;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'interest_method_type') THEN
    CREATE TYPE interest_method_type AS ENUM ('fixed','compounding');
  END IF;
END$$;

-- ------------------------------------------------
-- Tables
-- ------------------------------------------------

-- ============================================================
-- loans: one row per loan/contract
-- ============================================================
CREATE TABLE IF NOT EXISTS loans (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  loan_account_number VARCHAR(64) NOT NULL UNIQUE,

  contract_date DATE NOT NULL,
  first_payment_due DATE,

  -- next_payment_due is typically maintained by a trigger (below) or your app
  -- as the MIN(loan_payments.due_date) where is_paid = FALSE.
  next_payment_due DATE,

  -- expected_last_payment is typically maintained by trigger/app
  -- as the MAX(loan_payments.due_date) for the loan.
  expected_last_payment DATE,

  -- last_updated is a simple DATE marker; updated_at is the precise timestamp.
  last_updated DATE DEFAULT CURRENT_DATE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT now(),

  down_payment NUMERIC(14,2) NOT NULL DEFAULT 0 CHECK (down_payment >= 0),

  -- interest_rate is stored as a percent (e.g., 5.25 = 5.25%).
  interest_rate NUMERIC(7,4) CHECK (interest_rate IS NULL OR (interest_rate >= 0 AND interest_rate <= 100)),
  interest_method interest_method_type,

  number_of_years INT CHECK (number_of_years IS NULL OR number_of_years >= 0),
  payments_per_year INT CHECK (payments_per_year IS NULL OR payments_per_year > 0),

  -- IMPORTANT: payment_amount is a TEMPLATE/DEFAULT installment amount for schedule generation.
  -- It is NOT the authoritative record of what’s due each period—that lives in loan_payments.expected_amount.
  -- Typical flow: set this (e.g., 250.00) and copy it into each schedule row when generating plan.
  payment_amount NUMERIC(14,2) CHECK (payment_amount IS NULL OR payment_amount >= 0),

  -- total_amount_paid is maintained by trigger/app.
  -- By default (see trigger below) we sum ONLY installments marked as satisfied (is_paid=TRUE).
  -- If you prefer to count ALL cash received (including partials), see the commented ALT function below.
  total_amount_paid   NUMERIC(16,2) NOT NULL DEFAULT 0 CHECK (total_amount_paid >= 0),

  -- total_interest_paid is for interest accounting if you decompose receipts;
  -- maintain via app logic or by extending triggers.
  total_interest_paid NUMERIC(16,2) NOT NULL DEFAULT 0 CHECK (total_interest_paid >= 0),

  purchase_price NUMERIC(16,2) CHECK (purchase_price IS NULL OR purchase_price >= 0)
);

COMMENT ON COLUMN loans.payment_amount IS
'Default/template installment amount (e.g., 250.00). Real expectations live per-row in loan_payments.expected_amount.';
COMMENT ON COLUMN loans.total_amount_paid IS
'Aggregate of payments received. Default trigger sums only satisfied installments (is_paid=TRUE); switch to ALT trigger to include partials.';
COMMENT ON COLUMN loans.down_payment IS
'Best practice: also insert a PAID schedule row in loan_payments on contract_date with expected_amount=paid_amount=down_payment and is_paid=TRUE so totals count it exactly once.';

-- ============================================================
-- contacts: canonical people/organizations
-- ============================================================
CREATE TABLE IF NOT EXISTS contacts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  address VARCHAR(255),
  city VARCHAR(100),
  state VARCHAR(2),
  zip VARCHAR(20),
  phone VARCHAR(30),
  email VARCHAR(255),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Optional: avoid duplicate emails when provided
CREATE UNIQUE INDEX IF NOT EXISTS contacts_email_unique
  ON contacts (LOWER(email))
  WHERE email IS NOT NULL;

-- ============================================================
-- loan_parties: which contact plays what role on which loan
-- ============================================================
CREATE TABLE IF NOT EXISTS loan_parties (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  loan_id BIGINT NOT NULL REFERENCES loans(id) ON DELETE CASCADE,
  contact_id BIGINT NOT NULL REFERENCES contacts(id) ON DELETE RESTRICT,
  role loan_party_role NOT NULL,
  is_primary BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (loan_id, contact_id, role)  -- same person can’t be the same role twice on the same loan
);

CREATE INDEX IF NOT EXISTS loan_parties_loan_role_idx ON loan_parties (loan_id, role);
CREATE INDEX IF NOT EXISTS loan_parties_contact_idx   ON loan_parties (contact_id);

-- Ensure only one primary per role per loan (e.g., one primary buyer)
CREATE UNIQUE INDEX IF NOT EXISTS loan_parties_one_primary_per_role
  ON loan_parties (loan_id, role)
  WHERE is_primary = TRUE;

-- ============================================================
-- loan_payments: expected schedule + actuals (check-off workflow)
-- ============================================================
CREATE TABLE IF NOT EXISTS loan_payments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  loan_id BIGINT NOT NULL REFERENCES loans(id) ON DELETE CASCADE,

  -- Planned due date for this installment.
  due_date DATE NOT NULL,

  -- Authoritative expectation for THIS installment.
  -- Often equals loans.payment_amount, but can vary (prorates, fees, adjustments).
  expected_amount NUMERIC(14,2) NOT NULL CHECK (expected_amount >= 0),

  -- What has actually been paid toward THIS installment (can be partial or full).
  -- If you track multiple receipts, you can either sum them here,
  -- or create a loan_receipts table and keep this as a cached/cumulative value.
  paid_amount NUMERIC(14,2) CHECK (paid_amount IS NULL OR paid_amount >= 0),

  -- Factual date funds CLEARED for this installment.
  -- For partials: update to the FINAL clearance date when the installment becomes fully satisfied.
  paid_date DATE,

  -- Your “checkbox”: has this installment been satisfied?
  -- This is intentionally NOT auto-derived so you can treat short-pays/waivers as “paid” if business rules allow.
  -- Guardrail below enforces that if is_paid = TRUE, both paid_amount AND paid_date must be present.
  is_paid BOOLEAN NOT NULL DEFAULT FALSE,

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Prevent duplicate schedule rows for the same due date on the same loan.
  UNIQUE (loan_id, due_date),

  -- Guardrail: when marked paid, require both paid_amount and paid_date.
  CHECK (
    (is_paid = FALSE)
    OR
    (is_paid = TRUE AND paid_amount IS NOT NULL AND paid_date IS NOT NULL)
  )

  -- OPTIONAL (uncomment if you NEVER allow short-pays to count as “paid”):
  -- , CHECK (is_paid = FALSE OR paid_amount >= expected_amount)
);

COMMENT ON COLUMN loan_payments.expected_amount IS
'Authoritative per-installment expectation. This is what is due for that period.';
COMMENT ON COLUMN loan_payments.paid_amount IS
'Actual cash received toward this installment (allows partials). If using a receipts table, keep this as the running sum.';
COMMENT ON COLUMN loan_payments.paid_date IS
'Date funds cleared. For partials, set to the final clearance date when the installment becomes fully satisfied.';
COMMENT ON COLUMN loan_payments.is_paid IS
'Business decision that this installment is satisfied (not merely that cash arrived). Allows waivers/short-pays to count as paid if desired.';

CREATE INDEX IF NOT EXISTS loan_payments_loan_idx      ON loan_payments (loan_id);
CREATE INDEX IF NOT EXISTS loan_payments_due_idx       ON loan_payments (loan_id, due_date);
CREATE INDEX IF NOT EXISTS loan_payments_unpaid_idx    ON loan_payments (loan_id, is_paid, due_date);

-- ------------------------------------------------
-- Triggers: updated_at maintenance
-- ------------------------------------------------
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_loans_set_updated_at') THEN
    CREATE TRIGGER trg_loans_set_updated_at
    BEFORE UPDATE ON loans
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_contacts_set_updated_at') THEN
    CREATE TRIGGER trg_contacts_set_updated_at
    BEFORE UPDATE ON contacts
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_loan_parties_set_updated_at') THEN
    CREATE TRIGGER trg_loan_parties_set_updated_at
    BEFORE UPDATE ON loan_parties
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_loan_payments_set_updated_at') THEN
    CREATE TRIGGER trg_loan_payments_set_updated_at
    BEFORE UPDATE ON loan_payments
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
  END IF;
END$$;

-- ------------------------------------------------
-- Aggregates & due dates: keep loans.* in sync with loan_payments
-- ------------------------------------------------

-- DEFAULT behavior: only count installments *you have checked off* (is_paid=TRUE)
-- toward loans.total_amount_paid. This fits a “checklist” workflow.
CREATE OR REPLACE FUNCTION recompute_loan_aggregates()
RETURNS TRIGGER AS $$
DECLARE
  v_loan_id BIGINT;
BEGIN
  v_loan_id := COALESCE(NEW.loan_id, OLD.loan_id);

  UPDATE loans l
  SET
    total_amount_paid = COALESCE((
      SELECT SUM(lp.paid_amount)
      FROM loan_payments lp
      WHERE lp.loan_id = v_loan_id AND lp.is_paid = TRUE
    ), 0),
    next_payment_due = (
      SELECT MIN(lp.due_date)
      FROM loan_payments lp
      WHERE lp.loan_id = v_loan_id AND lp.is_paid = FALSE
    ),
    expected_last_payment = (
      SELECT MAX(lp.due_date)
      FROM loan_payments lp
      WHERE lp.loan_id = v_loan_id
    ),
    last_updated = CURRENT_DATE,
    updated_at = now()
  WHERE l.id = v_loan_id;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trg_loan_payments_recompute_aggregates') THEN
    CREATE TRIGGER trg_loan_payments_recompute_aggregates
    AFTER INSERT OR UPDATE OR DELETE ON loan_payments
    FOR EACH ROW EXECUTE FUNCTION recompute_loan_aggregates();
  END IF;
END$$;

-- ALT behavior (COMMENTED OUT): count ALL cash received (including partials)
-- To use this instead, uncomment, run, and replace the trigger function above.
--[[
CREATE OR REPLACE FUNCTION recompute_loan_aggregates()
RETURNS TRIGGER AS $$
DECLARE
  v_loan_id BIGINT;
BEGIN
  v_loan_id := COALESCE(NEW.loan_id, OLD.loan_id);

  UPDATE loans l
  SET
    total_amount_paid = COALESCE((
      SELECT SUM(COALESCE(lp.paid_amount,0))
      FROM loan_payments lp
      WHERE lp.loan_id = v_loan_id
    ), 0),
    next_payment_due = (
      SELECT MIN(lp.due_date)
      FROM loan_payments lp
      WHERE lp.loan_id = v_loan_id AND lp.is_paid = FALSE
    ),
    expected_last_payment = (
      SELECT MAX(lp.due_date)
      FROM loan_payments lp
      WHERE lp.loan_id = v_loan_id
    ),
    last_updated = CURRENT_DATE,
    updated_at = now()
  WHERE l.id = v_loan_id;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
]]--

-- ------------------------------------------------
-- Convenience views (query like separate role tables)
-- ------------------------------------------------
CREATE OR REPLACE VIEW loan_buyers AS
SELECT
  lp.id         AS loan_party_id,
  lp.loan_id,
  lp.contact_id,
  lp.is_primary,
  c.name,
  c.address,
  c.city,
  c.state,
  c.zip,
  c.phone,
  c.email,
  c.created_at AS contact_created_at,
  c.updated_at AS contact_updated_at
FROM loan_parties lp
JOIN contacts c ON c.id = lp.contact_id
WHERE lp.role = 'buyer';

CREATE OR REPLACE VIEW loan_sellers AS
SELECT
  lp.id         AS loan_party_id,
  lp.loan_id,
  lp.contact_id,
  lp.is_primary,
  c.name,
  c.address,
  c.city,
  c.state,
  c.zip,
  c.phone,
  c.email,
  c.created_at AS contact_created_at,
  c.updated_at AS contact_updated_at
FROM loan_parties lp
JOIN contacts c ON c.id = lp.contact_id
WHERE lp.role = 'seller';

-- ------------------------------------------------
-- Helpful comments (schema-level guidance)
-- ------------------------------------------------
COMMENT ON VIEW loan_buyers  IS 'Convenience view for buyers (role-filtered join of loan_parties and contacts).';
COMMENT ON VIEW loan_sellers IS 'Convenience view for sellers (role-filtered join of loan_parties and contacts).';

COMMIT;
